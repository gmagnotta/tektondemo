apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: helloservlet-source-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: helloservlet-m2-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: helloservlet-varlibcontainers-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
---
kind: ConfigMap
apiVersion: v1
metadata:
  name: helloservlet
data:
  dest-image-path: 'destinationpath:version'
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: prepare-deploy
spec:
  params:
    - name: image-path
      type: string
    - name: CONTEXT
      type: string
      default: .
    - name: deployment-file
      type: string
      default: deployment.yaml
    - name: commit
      type: string
  workspaces:
    - name: source
  steps:
    - name: replace
      image: registry.access.redhat.com/ubi8/ubi
      workingDir: $(workspaces.source.path)/$(params.CONTEXT)
      script: |
        #!/usr/bin/env bash
        IMAGE="$(params.image-path)"
        COMMIT="$(params.commit)"
        echo "Using image: $IMAGE"
        sed -i "s|{{IMAGE}}|$IMAGE|g" $(params.deployment-file)
        sed -i "s|{{COMMIT}}|$COMMIT|g" $(params.deployment-file)
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: mavenbuild
spec:
  params:
    - name: CONTEXT
      type: string
      default: .
    - name: MVN_ARGS
      type: string
      default: "clean package"
  workspaces:
    - name: source
    - name: m2
      mountPath: /home/jboss/.m2/repository
  steps:
    - name: build
      image: registry.access.redhat.com/ubi8/openjdk-11
      workingDir: $(workspaces.source.path)/$(params.CONTEXT)
      script: |
        #!/usr/bin/env bash
        echo "Start maven build"
        mvn -Duser.home=/home/jboss $(params.MVN_ARGS)
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: buildah
spec:
  params:
    - description: Reference of the image buildah will produce.
      name: IMAGE
      type: string
    - default: >-
        registry.redhat.io/rhel8/buildah@sha256:180c4d9849b6ab0e5465d30d4f3a77765cf0d852ca1cb1efb59d6e8c9f90d467
      description: The location of the buildah builder image.
      name: BUILDER_IMAGE
      type: string
    - default: overlay
      description: Set buildah storage driver
      name: STORAGE_DRIVER
      type: string
    - default: ./Dockerfile
      description: Path to the Dockerfile to build.
      name: DOCKERFILE
      type: string
    - default: .
      description: Path to the directory to use as context.
      name: CONTEXT
      type: string
    - default: 'true'
      description: >-
        Verify the TLS on the registry endpoint (for push/pull to a non-TLS
        registry)
      name: TLSVERIFY
      type: string
    - default: oci
      description: 'The format of the built container, oci or docker'
      name: FORMAT
      type: string
    - default: ''
      description: Extra parameters passed for the build command when building images.
      name: BUILD_EXTRA_ARGS
      type: string
    - default: ''
      description: Extra parameters passed for the push command when pushing images.
      name: PUSH_EXTRA_ARGS
      type: string
  results:
    - description: Digest of the image just built.
      name: IMAGE_DIGEST
  workspaces:
    - name: source
    - name: varlibcontainers
      mountPath: /var/lib/containers
  steps:
    - image: $(params.BUILDER_IMAGE)
      name: build
      resources: {}
      script: |
        buildah --storage-driver=$(params.STORAGE_DRIVER) bud \
          $(params.BUILD_EXTRA_ARGS) --format=$(params.FORMAT) \
          --tls-verify=$(params.TLSVERIFY) --no-cache \
          -f $(params.DOCKERFILE) -t $(params.IMAGE) $(params.CONTEXT)
      securityContext:
        privileged: true
      workingDir: $(workspaces.source.path)
    - image: $(params.BUILDER_IMAGE)
      name: push
      resources: {}
      script: |
        buildah --storage-driver=$(params.STORAGE_DRIVER) push \
          $(params.PUSH_EXTRA_ARGS) --tls-verify=$(params.TLSVERIFY) \
          --digestfile $(workspaces.source.path)/image-digest $(params.IMAGE) \
          docker://$(params.IMAGE)
      securityContext:
        privileged: true
      workingDir: $(workspaces.source.path)
    - image: $(params.BUILDER_IMAGE)
      name: digest-to-results
      resources: {}
      script: >-
        cat $(workspaces.source.path)/image-digest | tee
        /tekton/results/IMAGE_DIGEST
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: kubernetes-actions
spec:
  description: >-
    This task is the generic kubectl CLI task which can be used
    to run all kinds of k8s commands
  workspaces:
    - name: manifest-dir
#      optional: true
    - name: kubeconfig-dir
#      optional: true
  results:
    - name: output-result
      description: some result can be emitted if someone wants to.
  params:
    - name: script
      description: The Kubernetes CLI script to run
      type: string
      default: "kubectl $@"
    - name: args
      description: The Kubernetes CLI arguments to run
      type: array
      default:
        - "help"
    - name: image
      default: gcr.io/cloud-builders/kubectl@sha256:8ab94be8b2b4f3d117f02d868b39540fddd225447abf4014f7ba4765cb39f753 #image is huge
      description: Kubectl wrapper image
  steps:
    - name: kubectl
      image: $(params.image)
      workingDir: $(workspaces.manifest-dir.path)
      script: |
        #!/usr/bin/env bash

        if [[ -f $(workspaces.kubeconfig-dir.path)/kubeconfig ]]; then
          export KUBECONFIG=$(workspaces.kubeconfig-dir.path)/kubeconfig
        fi

        $(params.script)

      args:
        - "$(params.args)"
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: get-image-path
spec:
  params:
    - name: deployment-name
      type: string
  results:
    - name: imagepath
      description: the image where container was pushed to.
    - name: imagecommit
      description: the git commit.
  steps:
    - name: replace
      image: gcr.io/cloud-builders/kubectl@sha256:8ab94be8b2b4f3d117f02d868b39540fddd225447abf4014f7ba4765cb39f753
      script: |
        #!/usr/bin/env bash
        IMAGE_PATH=$(kubectl get deployment $(params.deployment-name) -o jsonpath='{.metadata.annotations.imagepath}')

        echo -n "$IMAGE_PATH" > $(results.imagepath.path)

        COMMIT=$(kubectl get deployment $(params.deployment-name) -o jsonpath='{.metadata.annotations.gitcommit}')

        echo -n "$COMMIT" > $(results.imagecommit.path)

        echo "Read image path is $IMAGE_PATH and commit is $COMMIT"
---
apiVersion: tekton.dev/v1beta1
kind: Task
metadata:
  name: get-push-path
spec:
  params:
    - name: configmap-name
      type: string
  results:
    - name: pushpath
      description: the image where container should be pushed to.
  steps:
    - name: replace
      image: gcr.io/cloud-builders/kubectl@sha256:8ab94be8b2b4f3d117f02d868b39540fddd225447abf4014f7ba4765cb39f753
      script: |
        #!/usr/bin/env bash
        IMAGE_PUSH_PATH=$(kubectl get configmap $(params.configmap-name) -o jsonpath='{.data.dest-image-path}')

        echo -n "$IMAGE_PUSH_PATH" > $(results.pushpath.path)

        echo "Image should be pushed to $IMAGE_PUSH_PATH"
---
# Internal OCP registry is located at image-registry.openshift-image-registry.svc:5000
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: helloservlet-devpipeline
spec:
  params:
    - name: repo-url
    - name: image-path
  workspaces:
    - name: src
    - name: m2
    - name: varlibcontainers
    - name: empty
  tasks:
    - name: fetch-repository
      taskRef:
        name: git-clone
        kind: ClusterTask
      workspaces:
        - name: output
          workspace: src
      params:
        - name: url
          value: $(params.repo-url)
        - name: deleteExisting
          value: "true"
    - name: compile
      taskRef:
        name: mavenbuild
      runAfter:
        - fetch-repository
      workspaces:
        - name: source
          workspace: src
        - name: m2
          workspace: m2
    - name: build
      taskRef:
        name: buildah
      runAfter:
        - compile
      params:
        - name: TLSVERIFY
          value: "false"
        - name: IMAGE
          value: $(params.image-path)
      workspaces:
        - name: source
          workspace: src
        - name: varlibcontainers
          workspace: varlibcontainers
    - name: prepare-deploy
      taskRef:
        name: prepare-deploy
      runAfter:
        - build
      workspaces:
        - name: source
          workspace: src
      params:
        - name: image-path
          value: "$(params.image-path)@$(tasks.build.results.IMAGE_DIGEST)"
        - name: deployment-file
          value: helloservlet.yaml
        - name: commit
          value: "$(tasks.fetch-repository.results.commit)"
    - name: deploy
      taskRef:
        name: kubernetes-actions
      runAfter:
        - prepare-deploy
      workspaces:
        - name: kubeconfig-dir
          workspace: empty
        - name: manifest-dir
          workspace: src
      params:
        - name: script
          value: |
            kubectl apply -f helloservlet.yaml
---
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: helloservlet-promotetointegrationpipeline
spec:
  workspaces:
    - name: src
    - name: empty
  tasks:
    - name: deploy
      taskRef:
        name: kubernetes-actions
      workspaces:
        - name: kubeconfig-dir
          workspace: empty
        - name: manifest-dir
          workspace: src
      params:
        - name: script
          value: |
            kubectl apply -f helloservlet.yaml --namespace=integration
---
# Internal OCP registry is located at image-registry.openshift-image-registry.svc:5000
apiVersion: tekton.dev/v1beta1
kind: Pipeline
metadata:
  name: helloservlet-releasepipeline
spec:
  workspaces:
    - name: empty
  tasks:
    - name: getimagepath
      taskRef:
        name: get-image-path
      params:
        - name: deployment-name
          value: "helloservlet"
    - name: getpushpath
      taskRef:
        name: get-push-path
      runAfter:
        - getimagepath
      params:
        - name: configmap-name
          value: "helloservlet"
    - name: copy
      taskRef:
        name: skopeo-copy
        kind: ClusterTask
      runAfter:
        - getpushpath
      workspaces:
        - name: images-url
          workspace: empty
      params:
        - name: srcImageURL
          value: "docker://$(tasks.getimagepath.results.imagepath)"
        - name: destImageURL
          value: "docker://$(tasks.getpushpath.results.pushpath)"
        - name: srcTLSverify
          value: "false"
